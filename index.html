<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teachable Machine with Microbit</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    <style>
        #uploaded-image {
            max-width: 300px;
            max-height: 300px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Teachable Machine with Microbit</h1>
    <input type="text" id="model-url" placeholder="Enter Teachable Machine model URL">
    <button onclick="loadModel()">Load Model</button>
    <br><br>
    <button onclick="connectSerial()">Connect to Microbit</button>
    <br><br>
    <input type="file" id="image-upload" accept="image/*">
    <button onclick="classifyUploadedImage()">Classify Uploaded Image</button>
    <br><br>
    <img id="uploaded-image" alt="Uploaded Image">
    <br><br>
    <div id="webcam-container"></div>
    <div id="label-container"></div>

    <script>
        let model, webcam, labelContainer, maxPredictions;
        let port, writer;

        async function loadModel() {
            const modelURL = document.getElementById("model-url").value;
            const modelURLSplit = modelURL.split("/");
            const modelID = modelURLSplit[modelURLSplit.length - 1];
            const modelJSON = `${modelURL}model.json`;
            const metadataJSON = `${modelURL}metadata.json`;

            model = await tmImage.load(modelJSON, metadataJSON);
            maxPredictions = model.getTotalClasses();

            labelContainer = document.getElementById("label-container");
            for (let i = 0; i < maxPredictions; i++) {
                labelContainer.appendChild(document.createElement("div"));
            }

            setupWebcam();
        }

        async function setupWebcam() {
            const flip = true;
            webcam = new tmImage.Webcam(200, 200, flip);
            await webcam.setup();
            await webcam.play();
            window.requestAnimationFrame(loop);

            document.getElementById("webcam-container").appendChild(webcam.canvas);
        }

        async function loop() {
            webcam.update();
            await predict();
            window.requestAnimationFrame(loop);
        }

        async function predict() {
            const prediction = await model.predict(webcam.canvas);
            for (let i = 0; i < maxPredictions; i++) {
                const classPrediction =
                    prediction[i].className + ": " + prediction[i].probability.toFixed(2);
                labelContainer.childNodes[i].innerHTML = classPrediction;
            }

            // Send the highest probability class to Microbit
            const highestProbClass = prediction.reduce((prev, current) => 
                (prev.probability > current.probability) ? prev : current
            );
            sendToMicrobit(highestProbClass.className);
        }

        async function classifyUploadedImage() {
            const imageUpload = document.getElementById('image-upload');
            const img = document.getElementById('uploaded-image');
            
            if (imageUpload.files && imageUpload.files[0]) {
                const reader = new FileReader();
                
                reader.onload = async function(e) {
                    img.src = e.target.result;
                    img.style.display = 'block';
                    
                    // Wait for the image to load before predicting
                    img.onload = async function() {
                        const prediction = await model.predict(img);
                        for (let i = 0; i < maxPredictions; i++) {
                            const classPrediction =
                                prediction[i].className + ": " + prediction[i].probability.toFixed(2);
                            labelContainer.childNodes[i].innerHTML = classPrediction;
                        }

                        // Send the highest probability class to Microbit
                        const highestProbClass = prediction.reduce((prev, current) => 
                            (prev.probability > current.probability) ? prev : current
                        );
                        sendToMicrobit(highestProbClass.className);
                    }
                }
                
                reader.readAsDataURL(imageUpload.files[0]);
            }
        }

        async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                writer = port.writable.getWriter();
                console.log('Serial connection established');
            } catch (err) {
                console.error('Error:', err);
            }
        }

        async function sendToMicrobit(className) {
            if (writer) {
                const encoder = new TextEncoder();
                const data = encoder.encode(className + '\n');
                await writer.write(data);
            }
        }
    </script>
</body>
</html>
